#include <pico/stdlib.h>
#include <pico/rand.h>
#include <stdio.h>
#include <tusb.h>
#include <stdlib.h>

#include "drako/display.h"
#include "drako/hardware/at28c64b.h"

// uncomment to see full printout of randomized_full_test
//#define RNG_FULL_TEST_DEBUG

void display_shell(display* disp);
void full_test(eeprom* prom, display* disp);
size_t randomized_full_test(eeprom* prom, display* disp, size_t nbytes);




int main() {
    stdio_init_all();
    gpio_init(25);
    gpio_set_dir(25, GPIO_OUT);

    // wait for serial connection
    while (!tud_cdc_connected()) {
        gpio_put(25, 1);
        sleep_ms(250);
        gpio_put(25, 0);
        sleep_ms(250);
    }
    // clear serial terminal
    sleep_ms(500);
    printf("\x1b");
    printf("[2J");

    // turn on on-board LED
    gpio_put(25, 1);

    // create eeprom struct and init
    eeprom prom;
    eeprom_init(&prom,
        0x000000FF,     // data bus on GPIO[0:7]
        0x001FFF00,     // addr bus on GPIO[8:20]
        26, 22, 21
    );

    // create display struct and init
    display disp;
    display_init(&disp);

    // run full test
    //full_test(&prom, &disp);
    randomized_full_test(&prom, &disp, 100);

    char buf[5] = "";
    uint16_t addr;
    while (true) {
        buf[0] = getchar();
        buf[1] = getchar();
        buf[2] = getchar();
        buf[3] = getchar();
        addr = strtoul(buf, NULL, 16);

        uint8_t byte;
        eeprom_read8(&prom, addr, &byte);
        printf("0x%04x has 0x%02x", addr, byte);
    }

    // turn off on-bard LED
    gpio_put(25, 0);

    return 0;
}




void display_shell(display* disp) {
    char dbuf[2];
    uint16_t mdata, ldata;
    while (true) {
        dbuf[1] = getchar();
        display_write(disp, 0x1c1c);
        dbuf[0] = getchar();
        switch (dbuf[0]) {
            case '0':
                ldata = DRKO_DISPL_0;
                break;
            case '1':
                ldata = DRKO_DISPL_1;
                break;
            case '2':
                ldata = DRKO_DISPL_2;
                break;
            case '3':
                ldata = DRKO_DISPL_3;
                break;
            case '4':
                ldata = DRKO_DISPL_4;
                break;
            case '5':
                ldata = DRKO_DISPL_5;
                break;
            case '6':
                ldata = DRKO_DISPL_6;
                break;
            case '7':
                ldata = DRKO_DISPL_7;
                break;
            case '8':
                ldata = DRKO_DISPL_8;
                break;
            case '9':
                ldata = DRKO_DISPL_9;
                break;
            case 'a':
                ldata = DRKO_DISPL_A;
                break;
            case 'b':
                ldata = DRKO_DISPL_B;
                break;
            case 'c':
                ldata = DRKO_DISPL_C;
                break;
            case 'd':
                ldata = DRKO_DISPL_D;
                break;
            case 'e':
                ldata = DRKO_DISPL_E;
                break;
            case 'f':
                ldata = DRKO_DISPL_F;
                break;
            default:
                ldata = DRKO_DISPL_P;
                break;
        };
        switch (dbuf[1]) {
            case '0':
                mdata = DRKO_DISPM_0;
                break;
            case '1':
                mdata = DRKO_DISPM_1;
                break;
            case '2':
                mdata = DRKO_DISPM_2;
                break;
            case '3':
                mdata = DRKO_DISPM_3;
                break;
            case '4':
                mdata = DRKO_DISPM_4;
                break;
            case '5':
                mdata = DRKO_DISPM_5;
                break;
            case '6':
                mdata = DRKO_DISPM_6;
                break;
            case '7':
                mdata = DRKO_DISPM_7;
                break;
            case '8':
                mdata = DRKO_DISPM_8;
                break;
            case '9':
                mdata = DRKO_DISPM_9;
                break;
            case 'a':
                mdata = DRKO_DISPM_A;
                break;
            case 'b':
                mdata = DRKO_DISPM_B;
                break;
            case 'c':
                mdata = DRKO_DISPM_C;
                break;
            case 'd':
                mdata = DRKO_DISPM_D;
                break;
            case 'e':
                mdata = DRKO_DISPM_E;
                break;
            case 'f':
                mdata = DRKO_DISPM_F;
                break;
            default:
                mdata = DRKO_DISPM_P;
                break;
        };

        display_write(disp, mdata|ldata);
    }
}


void full_test(eeprom* prom, display* disp) {
    // generate random starting address that's no greater than 0x0FFF
    uint32_t addr = get_rand_32() % 0x0FFF;

    // create array of to-be-generated bytes
    size_t n = 10;
    uint8_t bytes[n];

    // write `n` random values to eeprom sequentially.
    eeprom_select(prom);
    printf("        ADDR       BYTE\n");
    uint8_t i;
    for(i = 0; i < n; i++) {
        // generate random byte and save for later validation
        bytes[i] = get_rand_32() % 0xFF;
        // write byte to address (contiguously incremented)
        eeprom_write8(prom, addr + i, bytes[i]);
        // print update to serial
        printf("WRITE: 0x%.4x <--- 0x%.2x\n", addr+i, bytes[i]);
    }

    // read `n` values that were written to EEPROM starting at `addr`
    uint8_t byte;
    for(i = 0; i < n; i++) {
        eeprom_select(prom);
        eeprom_read8(prom, addr+i, &byte);
        if (byte == bytes[i])
            printf("READ : 0x%.4x ---> 0x%.2x     [CORRECT]\n", addr+i, byte);
        else
            printf("READ : 0x%.4x ---> 0x%.2x     [-ERROR-]\n", addr+i, byte);

        // display byte
        display_select(disp);
        display_hex(disp, byte);

        // sleep for 1s
        sleep_ms(1000);
    }
}


size_t randomized_full_test(eeprom* prom, display* disp, size_t nbytes) {
    // loop control vars
    size_t i, j;
    bool duplicateFound;


    // arrays to store rng addrs and bytes for checking
    uint16_t addrs[nbytes];
    uint8_t  bytes[nbytes];

    // clear display
    display_select(disp);
    display_clear(disp);
    display_hide(disp);

    // make sure to enable eeprom databus and chipselect
    eeprom_select(prom);


    printf("Running Test: Randomized Full Test\n");
    printf("    Writing random bytes to random addresses... \n");
#ifdef RNG_FULL_TEST_DEBUG
    printf("[WRITE TEST] Randomly generating addresses and bytes: \n");
    printf("[WRITE TEST]     ADDR      BYTE\n");
#endif

    // populate arrays and write rng bytes to their rng address
    for (i = 0; i < nbytes; i++) {
        // generate RNG addr and byte
        bytes[i] = (uint8_t )(get_rand_32() % UINT8_MAX);
        addrs[i] = (uint16_t)(get_rand_32() % 0x07FF);

        // make sure addr isnt already being tested
        while (true) {
            duplicateFound = false;
            for (j = 0; j < i; j++) {
                // if duplicate found, generate new rng addr and check again
                if (addrs[i] == addrs[j]) {
                    addrs[i] = (uint16_t)(get_rand_32() % 0x07FF);
                    duplicateFound = true;
                    break;
                }
            }

            // if no duplicate found, break loop
            if (!duplicateFound)
                break;
        }

        eeprom_write8(prom, addrs[i], bytes[i]);

#ifdef RNG_FULL_TEST_DEBUG
        printf("[WRITE TEST]    0x%04x    0x%02x\n", addrs[i], bytes[i]);
#endif
    }

    printf("    Validating writes...\n");
#ifdef RNG_FULL_TEST_DEBUG
    printf("[READ TEST] Checking written values:\n");
    printf("[READ TEST]      ADDR     BYTE    STATUS\n");
#endif

    // check written bytes
    uint8_t byte;
    size_t failCount = 0;
    for (i = 0; i < nbytes; i++) {
        // read byte from eeprom
        eeprom_read8(prom, addrs[i], &byte);

#ifdef RNG_FULL_TEST_DEBUG
        printf("[READ TEST]     0x%04x    0x%02x    ", addrs[i], byte);

        // check if read byte matches what was supposed to be written
        if (byte != bytes[i]) {
            failCount++;
            printf("FAIL    expected 0x%02x\n", bytes[i]);
        } else {
            printf("PASS\n");
        }
#endif
    }

    printf(
            "Randomized Full Test Completed.\n    Total Failures: %d\n    Grade: %s\n",
            failCount,
            failCount > 0 ? "FAIL" : "PASS"
    );
    return failCount;
}

